package com.aurilux.xar.world;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import net.minecraft.block.Block;
import net.minecraft.enchantment.EnchantmentProtection;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.item.EntityTNTPrimed;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.init.Blocks;
import net.minecraft.potion.PotionEffect;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.DamageSource;
import net.minecraft.util.MathHelper;
import net.minecraft.util.Vec3;
import net.minecraft.world.ChunkPosition;
import net.minecraft.world.Explosion;
import net.minecraft.world.World;

public class MutableExplosion extends Explosion {
	//FIXME Change most of this
	/** The maximum radius an explosion may have */
	public final int MAX_RADIUS = 16;
	
	//** The x-coord of the origin of the explosion */
	//private int originX = 0;
	//** The y-coord of the origin of the explosion */
	//private int originY = 0;
	//** The z-coord of the origin of the explosion */
	//private int originZ = 0;
	
	/** Whether or not the explosion deals damage to entities */
	private boolean inflictsDamage = true;
	/** Whether or not the explosion blows entities away */
	private boolean appliesForce = true;
	/** Whether or not to spawn the block destruction particles */
	private boolean spawnExtraParticles = true;
	/** Whether or not the explosion destroys blocks */
	private boolean destroysBlocks = false;
	/** Whether or not the explosion ignites flammable blocks */
	private boolean isFlaming = false;
	/** Whether or not the explosion spawns particles */
	private boolean isSmoking = false;
	/** Whether or not the explosion damage, force, etc scales by distance */
	private boolean scalesWithDistance = false;
	
	/** The time in ticks that an entity will be lit on fire */
	private int burnTime = 0;
	/** The multiplier for the force generated by the explosion*/
	private float forceMultiplier = 1.0F;
	/** The amount of damage this explosion will deal */
	private float damage = 0.0F;

	/** World in which to apply the explosion */
	private World world;
	/** The DamageSource of this explosion */
	private DamageSource source = null;
	/** The potion effect, if any, to apply to entities */
	private PotionEffect potionEffect;
	/** The flag that basically determines if explosions are allowed */
	private boolean mobGriefingFlag = false;
	/** Holds a list of the entities that will be affected by this explosion */
	private ArrayList<Entity> affectedEntities = new ArrayList<Entity>();
	/** Holds a list of the blocks that will be affected by this explosion */
	private ArrayList<ChunkPosition> affectedBlockLocations = new ArrayList<ChunkPosition>();
	/** The list of players affected by the explosion. Used to notify each client of an explosion */
	private Map<EntityPlayer, Vec3> affectedPlayers = new HashMap<EntityPlayer, Vec3>();

	public MutableExplosion(World world, Entity entity) {
		super(world, entity, 0, 0, 0, 0);
		this.world = world;
		mobGriefingFlag = this.world.getGameRules().getGameRuleBooleanValue("mobGriefing");
	}
	
	public void createExplosion(double originX, double originY, double originZ, float size) {
		/*explosionX = originX;
		explosionY = originY;
		explosionZ = originZ;
		explosionSize = size;
		
		//gather all the necessary information and perform all the necessary calculations before we resolve all of the effects of this explosion
		affectedWithinRadius();
		//play the sounds effect and spawn the explosion particles
        world.playSoundEffect(explosionX, explosionY, explosionZ, "random.explode", 4.0F, (1.0F + (world.rand.nextFloat() - world.rand.nextFloat()) * 0.2F) * 0.7F);
        String particleType = explosionSize >= 2.0F && isSmoking ? "hugeexplosion" : "largeexplosion";
        world.spawnParticle(particleType, explosionX, explosionY, explosionZ, 1.0D, 0.0D, 0.0D);
		float diameter = explosionSize * 2.0F;
		
		Iterator<ChunkPosition> locations = affectedBlockLocations.iterator();
		while (locations.hasNext()) {
			ChunkPosition location = locations.next();
			int xCoord = location.x, yCoord = location.y, zCoord = location.z;
			Block blockID = world.getBlock(xCoord, yCoord, zCoord);
			Block block = Blocks.blocksList[blockID];
			
			if (destroysBlocks && mobGriefingFlag) {
                if (blockID > 0) {
                    if (block.canDropFromExplosion(this)) {
                        block.dropBlockAsItemWithChance(world, xCoord, yCoord, zCoord, world.getBlockMetadata(xCoord, yCoord, zCoord), 1.0F / explosionSize, 0);
                    }
                    block.onBlockExploded(world, xCoord, yCoord, zCoord, this);
                }
			}
			if (isFlaming) {
                int blockBelowID = world.getBlockId(xCoord, yCoord - 1, zCoord);

                if (blockID == 0 && Block.opaqueCubeLookup[blockBelowID] && world.rand.nextInt(3) == 0) {
                    world.setBlock(xCoord, yCoord, zCoord, Block.fire.blockID);
                }
			}
			if (isSmoking && spawnExtraParticles) {
                double d0 = (double)((float)xCoord + world.rand.nextFloat());
                double d1 = (double)((float)yCoord + world.rand.nextFloat());
                double d2 = (double)((float)zCoord + world.rand.nextFloat());
                double d3 = d0 - explosionX;
                double d4 = d1 - explosionY;
                double d5 = d2 - explosionZ;
                double d6 = (double)MathHelper.sqrt_double(d3 * d3 + d4 * d4 + d5 * d5);
                d3 /= d6;
                d4 /= d6;
                d5 /= d6;
                double d7 = 0.5D / (d6 / (double)explosionSize + 0.1D);
                d7 *= (double)(world.rand.nextFloat() * world.rand.nextFloat() + 0.3F);
                d3 *= d7;
                d4 *= d7;
                d5 *= d7;
                world.spawnParticle("explode", (d0 + explosionX * 1.0D) / 2.0D, (d1 + explosionY * 1.0D) / 2.0D, (d2 + explosionZ * 1.0D) / 2.0D, d3, d4, d5);
                world.spawnParticle("smoke", d0, d1, d2, d3, d4, d5);
			}
		}
		
		//iterate through the two arrays applying all effects
		Iterator<Entity> entities = affectedEntities.iterator();
		Vec3 vec3 = world.getWorldVec3Pool().getVecFromPool(explosionX, explosionY, explosionZ);
		while (entities.hasNext()) {
			Entity entity = entities.next();
			double d7 = (scalesWithDistance ? entity.getDistance(explosionX, explosionY, explosionZ) / (double) diameter : 0.0D);

			if (d7 <= 1.0D) {
				double d0 = entity.posX - explosionX;
				double d1 = entity.posY + (double) entity.getEyeHeight() - explosionY;
				double d2 = entity.posZ - explosionZ;
				double d8 = (double) MathHelper.sqrt_double(d0 * d0 + d1 * d1 + d2 * d2);

				if (d8 != 0.0D) {
					d0 /= d8;
					d1 /= d8;
					d2 /= d8;
					double d9 = (double) world.getBlockDensity(vec3, entity.boundingBox);
					double d10 = (1.0D - d7) * d9;
					
					if (inflictsDamage) {
						float amount = (damage == 0.0F ? (float)((int)((d10 * d10 + d10) / 2.0D * 8.0D * diameter + 1.0D)) : damage * (float) d10);
						entity.attackEntityFrom(getDamageSource(), amount);
					}
					if (isFlaming && !entity.isImmuneToFire() && world.rand.nextFloat() < d10) {
						entity.setFire(burnTime);
					}
					if (appliesForce) {
						double d11 = EnchantmentProtection.func_92092_a(entity, d10);
						entity.motionX += d0 * d11 * forceMultiplier;
						entity.motionY += d1 * d11 * forceMultiplier;
						entity.motionZ += d2 * d11 * forceMultiplier;
					}
					if (potionEffect != null && entity instanceof EntityLivingBase) {
						((EntityLivingBase) entity).addPotionEffect(potionEffect);
					}
					if (entity instanceof EntityPlayer) {
						affectedPlayers.put((EntityPlayer) entity, world.getWorldVec3Pool().getVecFromPool(d0 * d10, d1 * d10, d2 * d10));
					}
				}
			}
		}*/
		
		notifyClients();
	}
	
	@SuppressWarnings("unchecked")
	private void affectedWithinRadius() {
		//determine the entities affected by the explosion
		int minX = MathHelper.floor_double(explosionX - (double) explosionSize - 1.0D);
		int maxX = MathHelper.floor_double(explosionX + (double) explosionSize + 1.0D);
		int minY = MathHelper.floor_double(explosionY - (double) explosionSize - 1.0D);
		int maxY = MathHelper.floor_double(explosionY + (double) explosionSize + 1.0D);
		int minZ = MathHelper.floor_double(explosionZ - (double) explosionSize - 1.0D);
		int maxZ = MathHelper.floor_double(explosionZ + (double) explosionSize + 1.0D);
		AxisAlignedBB bounds = AxisAlignedBB.getAABBPool().getAABB((double) minX, (double) minY, (double) minZ, (double) maxX, (double) maxY, (double) maxZ);
		affectedEntities.addAll(world.getEntitiesWithinAABBExcludingEntity(exploder, bounds));
		
		//determine the blocks affected by the explosion
		/*for (int x = 0; x < MAX_RADIUS; x++) {
			for (int y = 0; y < MAX_RADIUS; y++) {
				for (int z = 0; z < MAX_RADIUS; z++) {
					//if we are at the edges of the explosion's area
					if (x == 0 || x == MAX_RADIUS - 1 || y == 0 || y == MAX_RADIUS - 1 || z == 0 || z == MAX_RADIUS - 1) {
                        double d3 = (double)((float)x / ((float)MAX_RADIUS - 1.0F) * 2.0F - 1.0F);
                        double d4 = (double)((float)y / ((float)MAX_RADIUS - 1.0F) * 2.0F - 1.0F);
                        double d5 = (double)((float)z / ((float)MAX_RADIUS - 1.0F) * 2.0F - 1.0F);
                        double distance = Math.sqrt(d3 * d3 + d4 * d4 + d5 * d5);
						d3 /= distance;
						d4 /= distance;
						d5 /= distance;
						float f1 = explosionSize * (0.7F + world.rand.nextFloat() * 0.6F);
						double d0 = explosionX;
						double d1 = explosionY;
						double d2 = explosionZ;

						for (float f2 = 0.3F; f1 > 0.0F; f1 -= f2 * 0.75F) {
							int l = MathHelper.floor_double(d0);
							int i1 = MathHelper.floor_double(d1);
							int j1 = MathHelper.floor_double(d2);
							int blockID = world.getBlockId(l, i1, j1);

                            if (blockID > 0) {
                                Block block = Block.blocksList[blockID];
                                float f3 = this.exploder != null ? this.exploder.getBlockExplosionResistance(this, this.world, l, i1, j1, block) : block.getExplosionResistance(this.exploder, world, l, i1, j1, explosionX, explosionY, explosionZ);
                                f1 -= (f3 + 0.3F) * f2;
                            }

							if (f1 > 0.0F && (this.exploder == null || this.exploder.shouldExplodeBlock(this, this.world, l, i1, j1, blockID, f1))) {
								affectedBlockLocations.add(new ChunkPosition(l, i1, j1));
							}

							d0 += d3 * (double)f2;
							d1 += d4 * (double)f2;
							d2 += d5 * (double)f2;
						}
					}
				}
			}
		}*/
	}
	
	protected DamageSource getDamageSource() {
		return (source != null ? source : DamageSource.setExplosionSource(this));
	}
	
	public MutableExplosion setFlaming(boolean flaming, int ticks) {
		this.isFlaming = flaming;
		this.burnTime = ticks;
		return this;
	}
	
	public MutableExplosion setSmoking(boolean smoking) {
		this.isSmoking = smoking;
		return this;
	}
	
	public MutableExplosion setForce(boolean forces, float multiplier) {
		this.appliesForce = forces;
		this.forceMultiplier = multiplier;
		return this;
	}
	
	public MutableExplosion setDamage(boolean inflicts, int amount) {//, DamageSource ds) {
		this.inflictsDamage = inflicts;
		this.damage = amount;
		return this;
	}
	
	public MutableExplosion setPotionEffect(PotionEffect effect) {
		this.potionEffect = effect;
		return this;
	}
	
    public EntityLivingBase getExplosivePlacedBy() {
        return this.exploder == null ? null : (this.exploder instanceof EntityTNTPrimed ? ((EntityTNTPrimed)this.exploder).getTntPlacedBy() :
        	(this.exploder instanceof EntityLivingBase ? (EntityLivingBase)this.exploder : null));
    }
    
    @SuppressWarnings("rawtypes")
	private void notifyClients() {
		if (!world.isRemote) {
			Iterator iterator = world.playerEntities.iterator();
			while (iterator.hasNext()) {
				EntityPlayer entityplayer = (EntityPlayer)iterator.next();
				if (entityplayer.getDistanceSq(explosionX, explosionY, explosionZ) < 4096.0D) {
					//((EntityPlayerMP)entityplayer).playerNetServerHandler.sendPacketToPlayer(new Packet60Explosion(explosionX, explosionY, explosionZ, explosionSize, (destroysBlocks ? affectedBlockLocations : new ArrayList()), (Vec3)this.affectedPlayers.get(entityplayer)));
				}
			}
		}
	}
}
